//javascript color palette utilities
//needs colorEditorData.js, chroma.js

function colorItem(color, selected, palette, name, notes) {
	this.color = color
	this.selected = selected
	this.palette = palette
	this.name = color.hex()
	this.notes = notes
 }
function paletteItem(pName,pType, original, edited) {
	this.pName = pName
	this.pType = pType	//regular, sequential, formatting
	this.oColors = original
	this.eColors = edited
	this.gColors = []	//generated colors for sequentials
	this.version = 0
}

function initPalettes(state) {
	var pNames = ["New Palette","Tableau 10","Tableau 20","Tableau Light", "T10 Mod2"]
	state.palettes = []
	for (var i=0;i<pNames.length;i++) {
		var hex = hexFromName(pNames[i])
		state.palettes[i] = createPalette(hex, pNames[i])
	}
	setPalette(state,pNames[1])	 
}
function findPalette(palettes,pName) {
	for(var i=0;i<palettes.length;i++) {
		if (palettes[i].pName == pName) {return i}  //we're going to use pointers
	}
}
function addToPalette(palette, hex, selected) {
	var index = palette.eColors.length
	palette.eColors[index] = new colorItem(chroma(hex),selected,palette.pName,'regular')
	return palette.eColors[index]
}
function deleteFromPalette(palette,point) {
	if (point !=null) {
		for (var index=0; index<palette.length; index ++) {
			if (palette[index] == point) {
				palette.splice(index,1)
			}
		}
	}
}

function setPalette(state,pName) {
	state.palette = state.palettes[findPalette(state.palettes, pName)]
	state.colors = state.palette.eColors
	state.pOrder = []
	state.gColors = []	//generated by interpolation
}
//our colors are array[colorItem]. This makes an array[chroma.color]
//needed for the chroma interpolation functions
function colorsToChroma(colors) {
	var cColors = []
	for (var i=0; i<colors.length; i++) {
		cColors[i]=colors[i].color
	}
	return cColors
}
function chromaToColors(cColors,pName) {  //cColors are hex values
	var colors = []
	for (var i=0; i<cColors.length; i++) {
		colors[i]=new colorItem(chroma(cColors[i]),false,pName)
	}
	return colors
}
function sortColors(colors,sType) {
switch(sType) {
		case "L": 
			colors.sort(function(c1,c2){return byLCH(c1,c2,0)})
			break;
		case "C":
			colors.sort(function(c1,c2){return byLCH(c1,c2,2)})
			break;
		case "H":
			colors.sort(function(c1,c2){return byLCH(c1,c2,1)})
			break;
	}
	return colors
}

	
function byLCH(cItem1,cItem2, i1) { //colorItems
	var c1 = cItem1.color.lch()
	var c2 = cItem2.color.lch()
	if (c1[i1] > c2[i1]) {
		return 1
	}
	if (c1[i1] < c2[i1]) {
		return -1
	}
	// c1[i1] must be equal to c2[i1]
	return 0;
}

function makeClusters(nClusters,colors) {//list of colorItems
	var lch = []
	for (var i=0;i<colors.length;i++){
		lch[i] = colors[i].color.lch()
	}
	state.clusterMaker.data(lch)
	state.clusterMaker.k(nClusters)
	var clusters = state.clusterMaker.clusters()
	//now we have an array of {centroid, points}
	
}

function parseList(lString, isInt){
	var items = lString.trim().split(',')  //find some number of values
	var vals = []
	for (var i = 0; i<items.length; i++){
		if (isInt == true) {parseInt(items[i].trim())}
		else {vals[i] = parseFloat(items[i].trim())}
	}
	return vals
}
function parseHexString(hString) {
	var palettes = hString.trim().split("/")
	if (palettes[palettes.length-1]=="") {palettes = palettes.slice(0,-1)}	//dangling /
	var pVals = []
	for (var p = 0; p<palettes.length; p++) {
		hString = palettes[p]
		var hexValues = hString.trim().split(",") //clean up surrounding white space, then find commas
		if (hexValues[hexValues.length-1]=="") {hexValues = hexValues.slice(0,-1)}	//dangling ,
		for (var i = 0; i<hexValues.length; i++) { //now tidy each item
			hexValues[i] = hexValues[i].replace(/['"]+/g, '')  //remove quotes
			hexValues[i] = hexValues[i].trim()
		}
		var name =null
		//look for a name
		if (hexValues[0][0] != '#') { //assume it's a name plus the first hex value
			var front = hexValues[0].split('#')
			if (front.length != 2) {
				console.log("hex string error")
				console.log(hString)
				return {name: null, hex: null}
			} else { 
				hexValues[0] = "#"+front[1]	//put the # back on
				name = front[0].trim()  
				name =name.replace(/['"]+/g, '')  //remove quotes
			}
		}
		pVals[pVals.length] = {pName: name, hex: hexValues}
	}
	return pVals
}
function createHexString(colors, pName) {
	if (colors.length==0){return pName}
	var hexString
	if (pName !=null) {hexString = pName + '  '}
	hexString = hexString + colors[0].color.hex()
	for (var i = 1; i<colors.length; i++) {
		hexString = hexString+', '+colors[i].color.hex()
	}
	return hexString
}
function parseXML(xmlString) {
	var doc = jQuery.parseXML('<all>'+xmlString+'</all>')	//would be nice to catch an error here
	var pVals = []
	var palettes = $(doc).find("color-palette")
	$(palettes).each(function () {
			var pName = $(this).attr("name")  //no problem if this is null
			var pType = $(this).attr("type")
			var colors = $(this).find("color")	//array of <color>#vvvvvv</color>
			hexValues = []
			$(colors).each(function () {
				var c = $(this).text().trim()
				hexValues[hexValues.length] = c
			})
			pVals[pVals.length] = {pName: pName, pType: pType, hex: hexValues}
		})
	return pVals
}
function paletteToXML(colors, pName, pType) {
	var ptp = pType.split('.')	//picks a basic type
	var xml = ''
	if (ptp[0]=='formatting'){xml = paletteToFormattingXML(colors,ptp[1])}
	else {
		xml = '<color-palette name='+'\"'+pName+'\"'+' type = \"' + ptp[1] +'\">\n'
		for (var i=0;i<colors.length;i++) {
			xml = xml+'<color>'+colors[i].color.hex()+'</color>\n'
		}
		xml = xml+'</color-palette>\n'
	}
	return xml
}
function paletteToFormattingXML(colors, pType) {
	//pType = light, dark, gray
	var numStrings =['first','second','third','fourth','fifth', 'sixth', 'seventh', 'eighth', 'ninth']
	var xml = ""
	var xmlHead = ''
	var cLen = 3
	var nCols = 2
	var sCol = 0
	switch (pType) {
		case "light": {
			xmlHead = "<preference name=\'swatch.light."
			nCols = 9
			cLen = 6
			sCol = 2
			break
		}
		case "dark": {
			xmlHead = "<preference name=\'swatch.dark."
			nCols = 8
			cLen = 6
			sCol = 2
			break;
		}
		case 'gray': {
			sCol = 0
			nCols = 2
			cLen = 5
			xml = "<preference name='swatch.firstcol.firstrow' value='#000000' />\n"
			xml = xml+"<preference name='swatch.secondcol.firstrow' value='#ffffff' />\n"
			xmlHead = "<preference name='swatch."  //gray doesn't include a type
			break;	
		}
	}
	//now we fill in the rows and columns
	var cIndex = 0	//for the colors
	for (var col =0; col< nCols; col++){
		var gHack = 0;
		if (pType=='gray') {gHack = 1}	//force black and white to be at top
		var cHead = xmlHead+numStrings[sCol]+'col.'
		sCol = sCol+1
		for (var row=0; row < cLen; row++){
			if (cIndex>=colors.length){return xml}  
			xml = xml+cHead+numStrings[row+gHack]+"row'"
			xml = xml+ " value=\'"+colors[cIndex].color.hex()+"\' />\n"
			cIndex = cIndex+1
			if (cIndex>colors.length){return xml}  //ick, but two breaks is ick also
		}
	}				
	return xml
}
function createPalette(hex,pName,pType) {
	var colors = []
	for (var i=0; i< hex.length; i++) {
		colors[i] = new colorItem(chroma(hex[i]),false,pName,'regular')
	}
	var p =  new paletteItem(pName, pType, colors, copyColors(colors,pName))
	return p
}
function copyColors(cArray, pName) { //deep copy of an array of color items
	var colors = []
	for (var i=0; i<cArray.length; i++) {
		var c = cArray[i]
		colors[i] = new colorItem(chroma(c.color.hex()), c.selected, c.palette, c.name)
	}
	return colors
}

function copyPalette(palette,newName) {
	//we need to create new color elements for the new palette
	var colors = copyColors(palette.eColors,newName)
	var p =  new paletteItem(newName, palette.pType, colors, copyColors(colors,newName))
	return p
}


labToHex = function(labVals) {
	var hexVals = []
	var v =[]
	for (var i=0; i<labVals.length; i++) {
		v = labVals[i]
		hexVals[i] = chroma.lab(v[0],v[1],v[2]).hex()
	}
	return hexVals
}