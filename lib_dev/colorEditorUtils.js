//javascript color palette utilities
//needs colorEditorData.js, chroma.js

function colorItem(color, selected, palette, name, notes) {
	this.color = color
	this.selected = selected
	this.palette = palette
	this.name = color.hex()
	this.notes = notes
 }
function paletteItem(pName, pType, original, visible) {
	this.pName = pName
	this.pType = pType	//regular, sequential, diverging, 3xformatting
	this.oColors = original
	this.eColors = []	//edited colors
	this.pOrder = []  //a place to hold the original palette order when sorting
	this.gColors = []	//generated by the chroma.js scale. 
	if (visible !=undefined){this.visible = visible}
	else {this.visible = true}
}

function initPalettes(state) {
	state.palettes = []
	var selName = ''
	for (var i=0;i<allPalettes.length;i++) {
		var pVals =parseXML(allPalettes[i])[0]
		state.palettes[i] = createPalette(pVals.hex,pVals.pName,pVals.pType, true)
	}
	applyPFilters()	 
}

function createPalette(hex,pName,pType,visible) {
	var colors = []
	for (var i=0; i< hex.length; i++) {
		colors[i] = new colorItem(chroma(hex[i]),false,pName,hex)
	}
	var p =  new paletteItem(pName, pType, colors ,visible)
	p.eColors = copyColors(colors,pName)
	return p
}
function copyColors(cArray, pName) { //deep copy of an array of color items
	var colors = []
	for (var i=0; i<cArray.length; i++) {
		var c = cArray[i]
		colors[i] = new colorItem(chroma(c.color.hex()), c.selected, c.palette, c.name)
	}
	return colors
}

function copyPalette(palette,newName) {
	//we need to create new color elements for the new palette
	var colors = copyColors(palette.eColors,newName)
	var p =  new paletteItem(newName, palette.pType, colors)
	p.eColors = copyColors(colors,newName)
	return p
}

function applyPFilters() {
	for (var p=0; p<state.palettes.length; p++) {
		state.palettes[p].visible = pTypeToVisible(state.palettes[p].pType)	
	}
	var pName = null
	for (var p=0; p<state.palettes.length; p++) {
		if(state.palettes[p].visible) {
			pName = state.palettes[p].pName; break}
	}
	setPalette(state, pName)
	
}
// translate between pType and the state.visibleTypes filters
function pTypeToVisible(pType){
	var visible = false
	if (pType.includes('formatting')){pType = 'formatting'}
	switch (pType) {
		case "regular": 
			visible = state.visibleTypes.regular; break;
		case "ordered-sequential": 
			visible = state.visibleTypes.sequential; break;
		case "ordered-diverging": 
			visible = state.visibleTypes.diverging; break;
		case "formatting": 
			visible = state.visibleTypes.formatting; break;
		case 'none':
			visible = true; break;	//can't filter out the "new palette"
		default: 
			visible = false;
	}
	return visible			
}

function findPalette(palettes,pName) {
	for(var i=0;i<palettes.length;i++) {
		if (palettes[i].pName == pName) {return i}  //we're going to use pointers
	}
	return -1;
}
function addToPalette(palette, hex, selected) {
	var index = palette.eColors.length
	var color = new colorItem(chroma(hex),selected,palette.pName,hex)
	//if the color is a duplicate of the current selection
	//insert it after the current selection
	for (var i=0; i<index; i++) {
		if (hex==palette.eColors[i].color.hex()) {index = i; break}
	} 
	palette.eColors.splice(index,0,color)
	if (palette.pOrder.length > 0){
		palette.pOrder.push(color) //add it to the end
	}
	return palette.eColors[index]
}
function appendToPalette(palette,hexList,removeSimilar,minDE) {
	var c, hex
	for (var i = 0; i<hexList.length;i++ ){
		hex = hexList[i]
		c = new colorItem(chroma(hex),false,palette.pName,hex)
		if (removeSimilar==false) {
			palette.eColors.push(c)
		} else {
			var cList = findColor(c,palette.eColors, minDE)
			if (cList.length ==0) {palette.eColors.push(c)}
		}
			
	}
	
}
function deleteFromPalette(palette,point) {
	if (point !=null) {
		for (var index=0; index<palette.length; index ++) {
			if (palette[index] == point) {
				palette.splice(index,1)
			}
		}
	}
}

function setPalette(state,pName) {
	var pIndex = findPalette(state.palettes, pName)
	if (pIndex >=0) {
		state.palette = state.palettes[pIndex]
		state.colors = state.palette.eColors
	}
	else {
		state.palette = null
		state.colors = []
	}
}
//our colors are array[colorItem]. This makes an array[chroma.color]
//needed for the chroma interpolation functions
function colorsToChroma(colors) {
	var cColors = []
	for (var i=0; i<colors.length; i++) {
		cColors[i]=colors[i].color
	}
	return cColors
}
function chromaToColors(cColors,pName) {  //cColors are hex values
	var colors = []
	for (var i=0; i<cColors.length; i++) {
		colors[i]=new colorItem(chroma(cColors[i]),false,pName)
	}
	return colors
}
function sortColors(colors,sType) {
	switch(sType) {
			case "L": 
				colors.sort(function(c1,c2){return byLCH(c1,c2,0)})
				break;
			case "C":
				colors.sort(function(c1,c2){return byLCH(c1,c2,2)})
				break;
			case "H":
				colors.sort(function(c1,c2){return byLCH(c1,c2,1)})
				break;
		}
		return colors
}

/*function byMinDE(cItem1,cItem2) { //colorItems
	var dE = deltaE(cItem1,cItem2)
	if (c1[i1] > c2[i1]) {
		return 1
	}
	if (c1[i1] < c2[i1]) {
		return -1
	}
	// c1[i1] must be equal to c2[i1]
	return 0;
}*/
	
function byLCH(cItem1,cItem2, i1) { //colorItems
	var c1 = cItem1.color.lch()
	var c2 = cItem2.color.lch()
	if (c1[i1] > c2[i1]) {
		return 1
	}
	if (c1[i1] < c2[i1]) {
		return -1
	}
	// c1[i1] must be equal to c2[i1]
	return 0;
}

function makeClusters(nClusters,colors) {//list of colorItems
	var lch = []
	for (var i=0;i<colors.length;i++){
		lch[i] = colors[i].color.lch()
	}
	state.clusterMaker.data(lch)
	state.clusterMaker.k(nClusters)
	var clusters = state.clusterMaker.clusters()
	//now we have an array of {centroid, points}
	
}



function findColor(cItem,cList, minD){  //is the color in the list?
	var found = []
	for (var i = 0; i<cList.length; i++ ){
		if(deltaE(cItem.color,cList[i].color) <= minD) {
			found.push(cList[i])
		}
	}
return found
}

function computeStats(colors, dE_type){
	if (dE_type =='none') return null
	var stats = {dE:[], minE: 0, maxE:0, aveE:0, totalE: 0}
	var prev = colors[0]
	var total = 0
	for (var i=1; i<colors.length; i++) {
		if (dE_type =='dE94') {
			stats.dE[i-1] = deltaE94(prev.color,colors[i].color)
		}
		else {stats.dE[i-1] = deltaE(prev.color,colors[i].color)}
		total = total+stats.dE[i-1]
		prev = colors[i]
		stats.dE[i-1] = Math.round(stats.dE[i-1])
	}
	stats.minE = Math.min(...stats.dE)
	stats.maxE = Math.max(...stats.dE)
	stats.aveE = Math.round(total/stats.dE.length)
	stats.totalE = Math.round(total)
	return stats
}
//color differences between chroma.js colors
//the basic one.
function deltaE(c1,c2){
	var lab1 = c1.lab()
	var lab2 = c2.lab()
	var dL = lab1[0]-lab2[0]
	var da= lab1[1]-lab2[1]
	var db= lab1[2]-lab2[2]
	var dE = Math.sqrt(dL*dL+da*da+db*db)
	return dE
}

//A somewhat better one.
//But, note this is an asymmetric function, deltaE94(c1,c2) != deltaE94(c2,c1)
function deltaE94(c1,c2){  
	var lab1 = c1.lab()  //.lch() returns the wrong h
	var lab2 = c2.lab()
	var C1 = Math.sqrt(lab1[1]*lab1[1]+lab1[2]*lab1[2]) //sqrt(a*a+b*b)
	var C2 = Math.sqrt(lab2[1]*lab2[1]+lab2[2]*lab2[2]) //sqrt(a*a+b*b)
	var da= lab1[1]-lab2[1]
	var db= lab1[2]-lab2[2]
	var dC = C1-C2
	
	//various weights. There are also kL, kC, kH, but they are all 1.0
	var K1 = 0.045
	var K2 = 0.015
	var SL = 1
	var SC = 1+K1*C1  //note the dependency on C1 only
	var SH = 1+K2*C1
	//these factors are dV/SV, will distance them below
	var fdL = (lab1[0]-lab2[0])/SL
	var fdC = (C1-C2)/SC
	var fdH = Math.sqrt(da*da+db*db-(dC*dC))/SH
	var dE94 = Math.sqrt(fdL*fdL + fdC*fdC + fdH*fdH)
	return dE94
	
}